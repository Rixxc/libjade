from Jade require "crypto_sign/ed25519/amd64/common/load_store4.jinc"

require "sha512_api.jinc"
require "curve25519.jinc"
require "reduce_q4.jinc"
require "muladdq4.jinc"

fn jade_ed25519_amd64_keygen(reg u64 skp pkp) -> reg u64
{
  reg u64[4] sk pk h_red;
  stack u64[4] sks ks;
  reg u64 inlen r temp_64;
  stack u64 skps pkps;
  inline int i;
  
  stack u64[8] H;
  reg ptr u64[8] Hreg;
  stack ptr u64[8] Hregs;
  reg u64[8] h;
  stack u64[25] state;
  reg ptr u64[25] pstate;
  
  skps = skp;
  pkps = pkp;
  
  Hreg = H;
	Hregs = Hreg;
	
  sks = #randombytes(sks);
	sk = #copy(sks);
  
  skp = skps;
  __store4(skp, sk);
  skp += 8*4;
  skps = skp;
  
  pstate = state;
	pstate = sha512_init(pstate);
	state = pstate;
	
	pstate = state;
  pstate = sha512_update_32(pstate, sk);
  state = pstate;
  
  Hreg = Hregs;
	pstate = state;
	Hreg = sha512_finalize(pstate, Hreg);
	H = Hreg;
	h = #copy(H);
	state = pstate;
	
  ks = __decode_scalar(h);
  h_red = #copy(ks);
  
  pk = __curve25519_mulx_base(h_red);
  
  pkp = pkps;
  __store4(pkp, pk);
  skp = skps;
  __store4(skp, pk);
  

  ?{}, r = #set0();
  return r;
}

fn jade_ed25519_amd64_sign(reg u64 skp mp msg_len sigp) -> reg u64
{
  inline int i;
  reg u64[4] k s temp h_red R input;
  stack u64[4] rs ks;
  stack u64 msg_lens mps sigps;
  
  stack u64[8] H;
  reg ptr u64[8] Hreg;
	stack ptr u64[8] Hregs;
  reg u64[8] h;
  stack u64[8] hs;
  stack u64[25] state state_2;
	reg ptr u64[25] pstate pstate_2;
	reg u64 inlen r;
	
	msg_lens = msg_len;
	mps = mp;
	sigps = sigp;
	
	Hreg = H;
	Hregs = Hreg;
  
  pstate = state;
	pstate = sha512_init(pstate);
	state = pstate;
	
	pstate_2 = state_2;
	pstate_2 = sha512_init(pstate_2);
	state_2 = pstate_2;
	
	state[0] = (u64)[skp];
	state[1] = (u64)[skp+8];
	state[2] = (u64)[skp+16];
	state[3] = (u64)[skp+24];
	state[24] = 32;
  
  state_2[4] = (u64)[skp+32];
  state_2[5] = (u64)[skp+40];
  state_2[6] = (u64)[skp+48];
  state_2[7] = (u64)[skp+56];
  
  Hreg = Hregs;
	pstate = state;
	Hreg = sha512_finalize(pstate, Hreg);
	H = Hreg;
	h = #copy(H);
  Hregs = Hreg;
	
  hs = #copy(h);
  ks = __decode_scalar(h);
  
  pstate = state;
	pstate = sha512_init(pstate);
	state = pstate;
	
	h = #copy(hs);
	for i=0 to 4{
		input[i] = h[4+i];
	}
	
	state[0] = input[0];
	state[1] = input[1];
	state[2] = input[2];
	state[3] = input[3];
	state[24] = 32;
  
  pstate = state;
  mp = mps;
  msg_len = msg_lens;
  pstate = sha512_update_ext_align(pstate, mp, msg_len);
  state = pstate;
  
  Hreg = Hregs;
	pstate = state;
	Hreg = sha512_finalize(pstate, Hreg);
	H = Hreg;
	h = #copy(H);
	Hregs = Hreg;
  
  h_red = __reduce_q4(h);
  rs = #copy(h_red);
  R = __curve25519_mulx_base(h_red);
  
  sigp = sigps;
  __store4(sigp, R);
  sigp += 8*4;
  sigps = sigp;
	
	state_2[0] = R[0];
	state_2[1] = R[1];
	state_2[2] = R[2];
	state_2[3] = R[3];
	
	state_2[24] = 64;
	
  pstate_2 = state_2;
  mp = mps;
  msg_len = msg_lens;
  pstate_2 = sha512_update_ext_align(pstate_2, mp, msg_len);
  state_2 = pstate_2;
  
  Hreg = Hregs;
	pstate_2 = state_2;
	Hreg = sha512_finalize(pstate_2, Hreg);
	H = Hreg;
	h = #copy(H);
  Hregs = Hreg;
  
  h_red = __reduce_q4(h);
	
	k = #copy(ks);
	temp = #copy(rs);
  s = __muladd_q4(k, h_red, temp);
	
	sigp = sigps;
  __store4(sigp, s);
  
  ?{}, r = #set0();
  return r;
}

fn jade_ed25519_amd64_verify(reg u64 sigp pkp mp msg_len) -> reg u64
{
  reg u64 [4] B R s A h_red;
  reg u64[4] s_enc r_enc p d;
  stack u64[4] xb yb zb tb xr yr zr tr xabc yabc zabc;
  stack u64[4] Rs As Bs s_encs ps ds;
  stack u8 valid;
  stack u64 msg_lens mps sigps;
  
  stack u64[8] H;
  reg ptr u64[8] Hreg;
  stack ptr u64[8] Hregs;
  reg u64[8] h;
  stack u64[25] state;
  reg ptr u64[25] pstate;
  reg u64 inlen input vrfy_res temp_64;
  
  inline int i;
  
  msg_lens = msg_len;
  mps = mp;
  
  Hreg = H;
	Hregs = Hreg;
	
	sigp = sigp;
  R = __load4(sigp);
  Rs = #copy(R);
  sigps = sigp;
  A = __load4(pkp);
  As = #copy(A);
  
  d[0] = 0x75eb4dca135978a3;
  d[1] = 0x00700a4d4141d8ab;
  d[2] = 0x8cc740797779e898;
  d[3] = 0x52036cee2b6ffe73;
  ds = #copy(d);
  
  p[0] = 0xffffffffffffffed;
  p[1] = 0xffffffffffffffff;
  p[2] = 0xffffffffffffffff;
  p[3] = 0x7fffffffffffffff;
  ps = #copy(p);
  
  pstate = state;
	pstate = sha512_init(pstate);
	state = pstate;
	
	R = #copy(Rs);
	pstate = state;
  pstate = sha512_update_32(pstate, R);
  state = pstate;
	
	A = #copy(As);
	pstate = state;
  pstate = sha512_update_32(pstate, A);
  state = pstate;
  
  pstate = state;
  mp = mps;
  msg_len = msg_lens;
  pstate = sha512_update_ext(pstate, mp, msg_len);
  state = pstate;
  
  Hreg = Hregs;
	pstate = state;
	Hreg = sha512_finalize(pstate, Hreg);
	H = Hreg;
	h = #copy(H);
  Hregs = Hreg;
  
  h_red = __reduce_q4(h);
  for i=0 to 4{
  	temp_64 = As[i];
  	temp_64 = #BSWAP_64(temp_64);
  	A[3-i] = temp_64;
  }
  s_enc = __curve25519_mulx(h_red, A);
  for i=0 to 4{
  	temp_64 = s_enc[i];
  	temp_64 = #BSWAP_64(temp_64);
  	s_encs[3-i] = temp_64;
  }
  
  sigp = sigps;
  sigp += 8*4;
  s = __load4(sigp);
  B = __curve25519_mulx_base(s);
  Bs = #copy(B);
  
  xb, yb, zb, tb, valid = __decode_point(s_encs, ds, ps);
  for i=0 to 4{
  	temp_64 = Rs[i];
  	temp_64 = #BSWAP_64(temp_64);
  	R[3-i] = temp_64;
  }
  Rs = #copy(R);
  
  xr, yr, zr, tr, valid = __decode_point(Rs, ds, ps);
  _, _, _, _, xabc, yabc, zabc, _ = __add_and_double4(xr, yr, zr, tr, xb, yb, zb, tb, ds);
  
  r_enc = __encode_point(xabc, yabc, zabc, ps);
  
  B = #copy(Bs);
	valid = __cmp4_rr(r_enc, B);
	temp_64 = (64u)valid;
	vrfy_res = temp_64;
	vrfy_res &= 0x1;
  
  return vrfy_res;
}

